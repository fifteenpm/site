{
  "id": 3279,
  "name": "New Basic Shader",
  "fragment": "precision highp float;\nprecision highp int;\n\nuniform sampler2D iChannel1;\nuniform sampler2D iChannel0;\n// uniform vec2 resolution;\nuniform float time;\nvarying vec2 vUv;\n\nfloat rand(vec2 n) \n    {\n        return 0.5 + 0.5 * fract(sin(dot(n.xy, vec2(12.9898, 78.233))) * 43758.5453);\n    }\nfloat water(vec3 p) \n    {\n        float t = time / 4.;\n        p.z += t * 2.;\n        p.x += t * 2.;\n        vec3 c1 = texture2D(iChannel1, p.xz / 30.).xyz;\n        p.z += t * 3.;\n        p.x += t * 0.5;\n        vec3 c2 = texture2D(iChannel1, p.xz / 30.).xyz;\n        p.z += t * 4.;\n        p.x += t * 0.8;\n        vec3 c3 = texture2D(iChannel1, p.xz / 30.).xyz;\n        c1 += c2 - c3;\n        float z = (c1.x + c1.y + c1.z) / 3.;\n        return p.y + z / 4.;\n    }\nfloat map(vec3 p) \n    {\n        float d = 100.0;\n        d = water(p);\n        return d;\n    }\nfloat intersect(vec3 ro, vec3 rd) \n    {\n        float d = 0.0;\n        for (int i = 0; i <= 100; i++) \n        {\n            float h = map(ro + rd * d);\n            if (h < 0.1) return d;\n             d += h;\n        }\n        return 0.0;\n    }\nvec3 norm(vec3 p) \n    {\n        float eps = .1;\n        return normalize(vec3(map(p + vec3(eps, 0, 0)) - map(p + vec3(-eps, 0, 0)), map(p + vec3(0, eps, 0)) - map(p + vec3(0, -eps, 0)), map(p + vec3(0, 0, eps)) - map(p + vec3(0, 0, -eps))));\n    }\nvoid main() \n    {\n        // vec2 uv = vUv.xy / resolution.xy - 0.5;\n        // uv.x *= resolution.x / resolution.y;\n        vec2 vUvReduced = vUv - 0.5;\n        vec3 l1 = normalize(vec3(1, 1, 1));\n        vec3 ro = vec3(-3, 7, -5);\n        vec3 rc = vec3(0, 0, 0);\n        vec3 ww = normalize(rc - ro);\n        vec3 uu = normalize(cross(vec3(0, 1, 0), ww));\n        vec3 vv = normalize(cross(rc - ro, uu));\n        vec3 rd = normalize(uu * vUvReduced.x + vv * vUvReduced.y + ww);\n        // vec3 rd = normalize(uu * uv.x + vv * uv.y + ww);\n        float d = intersect(ro, rd);\n        vec3 c = vec3(0.0);\n        if (d > 0.0) \n        {\n            vec3 p = ro + rd * d;\n            vec3 n = norm(p);\n            float spc = pow(max(0.0, dot(reflect(l1, n), rd)), 30.0);\n            vec4 ref = texture2D(iChannel0, normalize(reflect(rd, n)).xy);\n            vec3 rfa = texture2D(iChannel1, (p + n).xz / 6.0).xyz * (8. / d);\n            c = rfa.xyz + (ref.xyz * 0.5) + spc;\n        }\n         gl_FragColor = vec4(vec3(c), 1.0);\n    }\n",
  "vertex": "/**\n* Example Vertex Shader\n* Sets the position of the vertex by setting gl_Position\n*/\n\n// Set the precision for data types used in this shader\nprecision highp float;\nprecision highp int;\n\n// Default THREE.js uniforms available to both fragment and vertex shader\nuniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\n\n// Default uniforms provided by ShaderFrog.\nuniform vec3 cameraPosition;\nuniform float time;\n\n// Default attributes provided by THREE.js. Attributes are only available in the\n// vertex shader. You can pass them to the fragment shader using varyings\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\nattribute vec2 uv2;\n\n// Examples of variables passed from vertex to fragment shader\nvarying vec3 vPosition;\nvarying vec3 vNormal;\nvarying vec2 vUv;\nvarying vec2 vUv2;\n\nvoid main() {\n\n    // To pass variables to the fragment shader, you assign them here in the\n    // main function. Traditionally you name the varying with vAttributeName\n    vNormal = normal;\n    vUv = uv;\n    vUv2 = uv2;\n    vPosition = position;\n\n    // This sets the position of the vertex in 3d space. The correct math is\n    // provided below to take into account camera and object data.\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n}",
  "uniforms": {
    "cameraPosition": {
      "name": "cameraPosition",
      "displayName": null,
      "type": "v3",
      "glslType": "vec3",
      "useGridHelper": false,
      "useRange": false,
      "range": null,
      "isRandom": false,
      "randomRange": null,
      "useToggle": false,
      "toggle": null,
      "description": ""
    },
    "time": {
      "name": "time",
      "displayName": null,
      "type": "f",
      "glslType": "float",
      "useGridHelper": false,
      "useRange": false,
      "range": null,
      "isRandom": false,
      "randomRange": null,
      "useToggle": false,
      "toggle": null,
      "description": ""
    },
    "iChannel1": {
      "name": "iChannel1",
      "displayName": null,
      "type": "t",
      "glslType": "sampler2D",
      "useGridHelper": false,
      "useRange": false,
      "range": null,
      "isRandom": false,
      "randomRange": null,
      "useToggle": false,
      "toggle": null,
      "description": ""
    },
    "iChannel0": {
      "name": "iChannel0",
      "displayName": null,
      "type": "t",
      "glslType": "sampler2D",
      "useGridHelper": false,
      "useRange": false,
      "range": null,
      "isRandom": false,
      "randomRange": null,
      "useToggle": false,
      "toggle": null,
      "description": ""
    }
  },
  "url": "http://shaderfrog.com/app/view/3279",
  "user": {
    "username": "dev",
    "url": "http://shaderfrog.com/app/profile/andrewray"
  }
}